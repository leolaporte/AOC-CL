;;;; Day###.lisp
;;;; 2022 AOC Day ### solution
;;;; Leo Laporte, 5 Dec 2022

;; ----------------------------------------------------------------------------------------------------
;; Prologue code for setup - same every day
;; ----------------------------------------------------------------------------------------------------
(ql:quickload '(:fiveam :cl-ppcre :alexandria))

(defpackage :day05
  (:use #:cl
	#:fiveam       ; for inline testing
	#:cl-ppcre     ; regex
	#:alexandria)) ; lil utilities

(in-package :day05)

(setf fiveam:*run-test-when-defined* t) ; test when compiling test code (for quick iteration)
(declaim (optimize (debug 3)))          ; max debugging info

(defparameter *data-file* "~/cl/AOC/2022/day05/input.txt")  ; supplied data from AoC

#|
--- Day 5: Supply Stacks ---

--- Part One ---

After the rearrangement procedure completes, what crate ends up on top of each stack?

NOTES: The word STACKS is very relevant. These are LIFO stacks.
The problem is actually very simple... once we ingest the data.
Prepopulate the stacks then push and pop your way to victory!

Lisp's push and pop commands do exactly this to a list.
But first, how to turn the supplied data into an arbitrary
array of lists??

OK it took me four hours(!) but it's done. It's 1am - I'll comment and clean up in the
morning. G'night!
|#

(defparameter *test-data*
  '("    [D]    "
    "[N] [C]    "
    "[Z] [M] [P]"
    " 1   2   3 "
    ""
    "move 1 from 2 to 1"
    "move 3 from 1 to 3"
    "move 2 from 2 to 1"
    "move 1 from 1 to 2"))

(defparameter *inst-string* (create-scanner "^move (\\d+) from (\\d+) to (\\d+)$")
  "captures the three digits in each move string: how many crates from where to where")

(defun split-data (input-list)
  "splits a list of strings into two parts: the starting stacks contents, and the rearrangement
instructions"
  (labels ((contains-move? (s) (equal (first (uiop:split-string s)) "move"))) ; look for "move"
    (let ((stacks (remove-if #'contains-move? input-list))                    ; stacks description
	  (instructions (remove-if-not #'contains-move? input-list)))         ; move instructions
      (values (reverse stacks)  ; return stack descriptor strings reversed (so we can push them)
	      instructions))))  ; return the list of instructions in order

(defun build-stacks (stack-strings)
  "return an array of lists of strings representing the stacks described in s"
  (do* ((dim (parse-integer
	      (subseq (reverse (second stack-strings)) 1 3))) ; how many stacks? (assume 1 digit? TK)
	(stack-array (make-array dim :element-type 'list
				     :initial-element nil))   ; create empty stack array
	(ss (rest (rest stack-strings)) (rest ss)))           ; walk through stack strings
       ((null ss) stack-array)                                ; all done, return the array

    ;; body of do loop, do this for each string in the stack-strings
    (dotimes (i dim)  ; for each stack in stack-array
      (let* ((pos (1+ (* i 4)))                      ; position of stack letter (might be space)
	     (letter (subseq (first ss) pos (1+ pos))))
	(if (not (equalp letter " "))               ; don't bother to push spaces, just letters
	    (push letter (aref stack-array i))))))) ; push it to the proper stack in the array

(defun execute-instructions (stacks insts)
  "given an array of stacks, executes the provided list of instructions to move blocks on stacks"
  (dolist (i insts)                                  ; do this for each instruction in the list
    (register-groups-bind                            ; use regex to get the parameters
	((#'parse-integer how-many source dest))     ; how many crates move from source to dest stack
	(*inst-string* i)                            ; regex the instruction

      (dotimes (j how-many)                          ; do this for each crate
	(push
	 (pop (aref stacks (1- source)))  ; get letter to push (adjusting for 0 indexed array)
	 (aref stacks (1- dest)))))))     ; push it on destination stack


(defun day05-1 (input-list)
  "given the AOC input list of strings, print the message generated by applying
the move instructions to the stacks of letters"
  (multiple-value-bind (stack-strings inst-list) (split-data input-list) ; get stacks and instructions
    (let ((stacks (build-stacks stack-strings)))                         ; create stack array
      (execute-instructions stacks inst-list)                            ; execute all move instructions

      (reduce #'uiop:strcat                           ; turn string list into pretty string
	      (loop for i below (length stacks)       ; now get the top letter from each stack
		    collect (first (aref stacks i)))))))

(test day05-1-test
  (is (equalp "CMZ" (day05-1 *test-data*))))

#|
--- Part Two ---

The CrateMover 9001 is notable for many new and exciting features: air conditioning,
leather seats, an extra cup holder, and the ability to pick up and move multiple crates at once.

|#

(defun execute-instructions-2 (stacks insts)
  "given an array of stacks, executes the provided list of instructions to move blocks on stacks,
this time in chunks instead of one at a time"
  (dolist (i insts)                                                  ; do the following for each move
    (register-groups-bind
	((#'parse-integer how-many source dest))                     ; get the move parameters
	(*inst-string* i)

      (do ((chunk                                                     ; work through a chunk
	    (reverse (subseq (aref stacks (1- source)) 0 how-many))   ; get the whole chunk - reverse it
	    (rest chunk)))                                      ; get next piece of the chunk
	  ((null chunk))                                        ; we've done all the chunks - return
	(progn
	  (push (first chunk) (aref stacks (1- dest)))        ; push the chunk in reverse order
	  (pop (aref stacks (1- source))))))))                ; delete the chunk from the source

(defun day05-2 (input-list)
  "given the AOC input list of strings, print the message generated by applying
the move instructions to the stacks of letters"
  (multiple-value-bind (stack-strings inst-list) (split-data input-list) ; split input data
    (let ((stacks (build-stacks stack-strings)))                         ; create stack array
      (execute-instructions-2 stacks inst-list)                          ; execute all move instructions

      (reduce #'uiop:strcat                                   ; turn list of char into pretty string
	      (loop for i below (length stacks)               ; get the top letter from each stack
		    collect (first (aref stacks i)))))))

(test day05-2-test
  (is (equalp "MCD" (day05-2 *test-data*))))

;; now solve the puzzle!
(time (format t "The answer to AOC 2022 Day 05 Part 1 is ~a"
	      (day05-1 (uiop:read-file-lines *data-file*))))

(time (format t "The answer to AOC 2022 Day 05 Part 2 is ~a"
	      (day05-2 (uiop:read-file-lines *data-file*))))

;; --------------------------------------------------------------------------------
;; Timings with SBCL on Mac Studio M1 Max with 32GB RAM
;; --------------------------------------------------------------------------------

;; The answer to AOC 2022 Day 05 Part 1 is (J C M H L V G M G)
;; Evaluation took:
;; 0.001 seconds of real time
;; 0.001490 seconds of total run time (0.001308 user, 0.000182 system)
;; 100.00% CPU
;; 523,216 bytes consed

;; The answer to AOC 2022 Day 05 Part 2 is (L V M R W S S P Z)
;; Evaluation took:
;; 0.001 seconds of real time
;; 0.001558 seconds of total run time (0.001362 user, 0.000196 system)
;; 200.00% CPU
;; 653,296 bytes consed

;; --------Part 1--------   --------Part 2--------
;; Day       Time   Rank  Score       Time   Rank  Score
;; 5   03:01:38  23370      0   03:55:49  26420      0
;; 4   01:01:11  15964      0   01:16:38  16172      0
;; 3   00:42:32  12585      0   01:17:33  13957      0
;; 2   01:25:57  19891      0   01:57:08  20821      0
;; 1   00:36:07  10562      0   00:46:09  10629      0
